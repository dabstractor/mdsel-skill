{
  "backlog": [
    {
      "type": "Phase",
      "id": "P1",
      "title": "MVP: Core MCP Server with Two Tools",
      "status": "Planned",
      "description": "Implement the minimal MCP server exposing mdsel_index and mdsel_select tools with verbatim passthrough to mdsel CLI. No hooks, no behavioral conditioning - just the core tool surface.",
      "milestones": [
        {
          "type": "Milestone",
          "id": "P1.M1",
          "title": "Project Scaffolding",
          "status": "Complete",
          "description": "Initialize TypeScript project with MCP SDK, build tooling, and test framework.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M1.T1",
              "title": "Initialize Node.js TypeScript Project",
              "status": "Complete",
              "description": "Create package.json with ESM configuration, TypeScript, and MCP SDK dependency.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S1",
                  "title": "Create package.json with ESM and dependencies",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Project uses Node.js >=18.0.0, ESM modules (see plan/architecture/external_deps.md).\n2. INPUT: None (greenfield project).\n3. LOGIC: Create package.json with: name='mdsel-claude', type='module', engines.node='>=18.0.0'. Add dependencies: '@modelcontextprotocol/sdk'. Add devDependencies: typescript@^5.x, @types/node@^22.x, tsup@^8.x, vitest@^2.x, eslint@^9.x, prettier@^3.x. Add scripts: build, dev, test, lint, format.\n4. OUTPUT: /package.json ready for npm install."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S2",
                  "title": "Create tsconfig.json for ESM output",
                  "status": "Complete",
                  "story_points": 0.5,
                  "dependencies": [
                    "P1.M1.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Must target ES2022+ for ESM compatibility.\n2. INPUT: package.json from P1.M1.T1.S1 confirming ESM ('type': 'module').\n3. LOGIC: Create tsconfig.json with: target='ES2022', module='ESNext', moduleResolution='bundler', strict=true, outDir='dist', rootDir='src', declaration=true.\n4. OUTPUT: /tsconfig.json enabling TypeScript compilation."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S3",
                  "title": "Create tsup.config.ts for bundling",
                  "status": "Complete",
                  "story_points": 0.5,
                  "dependencies": [
                    "P1.M1.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: tsup bundles TypeScript to ESM (see mdsel project pattern).\n2. INPUT: tsconfig.json from P1.M1.T1.S2.\n3. LOGIC: Create tsup.config.ts with: entry=['src/index.ts'], format=['esm'], target='node18', clean=true, dts=true, outExtension='.mjs'.\n4. OUTPUT: /tsup.config.ts for 'npm run build'."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S4",
                  "title": "Create vitest.config.ts for testing",
                  "status": "Complete",
                  "story_points": 0.5,
                  "dependencies": [
                    "P1.M1.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: vitest is the test framework (see mdsel project).\n2. INPUT: tsconfig.json from P1.M1.T1.S2.\n3. LOGIC: Create vitest.config.ts with: test.globals=true, test.environment='node', test.include=['tests/**/*.test.ts'].\n4. OUTPUT: /vitest.config.ts for 'npm test'."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S5",
                  "title": "Create source directory structure",
                  "status": "Complete",
                  "story_points": 0.5,
                  "dependencies": [
                    "P1.M1.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Structure defined in plan/architecture/external_deps.md.\n2. INPUT: package.json from P1.M1.T1.S1.\n3. LOGIC: Create directories: src/, src/tools/, src/hooks/, src/lib/, tests/, tests/tools/, tests/hooks/, tests/lib/. Create placeholder files: src/index.ts (empty export), src/types.ts (empty).\n4. OUTPUT: Directory structure ready for implementation."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P1.M2",
          "title": "mdsel CLI Wrapper",
          "status": "Planned",
          "description": "Implement thin wrapper around mdsel CLI that executes commands and returns JSON output verbatim.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M2.T1",
              "title": "Implement mdsel CLI Executor",
              "status": "Planned",
              "description": "Create utility to spawn mdsel subprocess and capture JSON output.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M2.T1.S1",
                  "title": "Define MdselResult type interface",
                  "status": "Planned",
                  "story_points": 0.5,
                  "dependencies": [
                    "P1.M1.T1.S5"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: mdsel JSON output format documented in plan/architecture/external_deps.md.\n2. INPUT: Directory structure from P1.M1.T1.S5.\n3. LOGIC: In src/types.ts, define interfaces: MdselResult { success: boolean; stdout: string; stderr: string; exitCode: number }. Also define MdselIndexResponse and MdselSelectResponse matching mdsel's JSON schema (see external_deps.md).\n4. OUTPUT: src/types.ts with MdselResult, MdselIndexResponse, MdselSelectResponse interfaces for P1.M2.T1.S2."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T1.S2",
                  "title": "Implement execMdsel function",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: mdsel located at /home/dustin/.local/bin/mdsel, always use --json flag.\n2. INPUT: MdselResult interface from P1.M2.T1.S1.\n3. LOGIC: Create src/lib/mdsel-cli.ts. Implement async function execMdsel(args: string[]): Promise<MdselResult>. Use child_process.spawn with 'mdsel' command. Always append '--json' to args. Capture stdout/stderr. Return { success: exitCode === 0, stdout, stderr, exitCode }. Do NOT parse JSON - return raw stdout.\n4. OUTPUT: src/lib/mdsel-cli.ts exporting execMdsel() for tool handlers."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T1.S3",
                  "title": "Write tests for execMdsel",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Tests verify subprocess execution and JSON passthrough.\n2. INPUT: execMdsel function from P1.M2.T1.S2.\n3. LOGIC: Create tests/lib/mdsel-cli.test.ts. Test cases: (1) execMdsel(['index', 'test.md']) returns valid JSON stdout, (2) execMdsel with invalid file returns success=false, (3) stderr captured on errors, (4) --json flag always appended. Create test fixtures in tests/fixtures/sample.md.\n4. OUTPUT: tests/lib/mdsel-cli.test.ts with passing tests."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P1.M3",
          "title": "MCP Tool Handlers",
          "status": "Planned",
          "description": "Implement mdsel_index and mdsel_select tool handlers that delegate to mdsel CLI.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M3.T1",
              "title": "Implement mdsel_index Tool",
              "status": "Planned",
              "description": "Create tool handler for mdsel_index that calls mdsel index and returns JSON verbatim.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M3.T1.S1",
                  "title": "Define mdsel_index input schema",
                  "status": "Planned",
                  "story_points": 0.5,
                  "dependencies": [
                    "P1.M2.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Tool definition in plan/architecture/tool_definitions.md.\n2. INPUT: MdselResult interface from P1.M2.T1.S1.\n3. LOGIC: In src/tools/mdsel-index.ts, define MDSEL_INDEX_SCHEMA constant with inputSchema: { type: 'object', properties: { files: { type: 'array', items: { type: 'string' }, description: 'Array of absolute file paths to Markdown documents to index' } }, required: ['files'] }.\n4. OUTPUT: src/tools/mdsel-index.ts with schema constant for P1.M3.T1.S2."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T1.S2",
                  "title": "Implement handleMdselIndex function",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Must return mdsel output verbatim with no post-processing (PRD Section 4.1).\n2. INPUT: MDSEL_INDEX_SCHEMA from P1.M3.T1.S1, execMdsel from P1.M2.T1.S2.\n3. LOGIC: In src/tools/mdsel-index.ts, implement async function handleMdselIndex(args: { files: string[] }): Promise<ToolResult>. Call execMdsel(['index', ...args.files]). Return { content: [{ type: 'text', text: result.stdout }], isError: !result.success }. No JSON parsing, no transformation.\n4. OUTPUT: src/tools/mdsel-index.ts with handleMdselIndex() for MCP server."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T1.S3",
                  "title": "Write tests for mdsel_index handler",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Test verbatim passthrough and error handling.\n2. INPUT: handleMdselIndex from P1.M3.T1.S2.\n3. LOGIC: Create tests/tools/mdsel-index.test.ts. Test cases: (1) Valid file returns JSON with success=true in content, (2) Invalid file returns isError=true with mdsel error JSON, (3) Multiple files work correctly, (4) Output is raw mdsel JSON (not parsed/modified). Mock execMdsel for unit tests.\n4. OUTPUT: tests/tools/mdsel-index.test.ts with passing tests."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M3.T2",
              "title": "Implement mdsel_select Tool",
              "status": "Planned",
              "description": "Create tool handler for mdsel_select that calls mdsel select and returns JSON verbatim.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M3.T2.S1",
                  "title": "Define mdsel_select input schema",
                  "status": "Planned",
                  "story_points": 0.5,
                  "dependencies": [
                    "P1.M2.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Tool definition in plan/architecture/tool_definitions.md.\n2. INPUT: MdselResult interface from P1.M2.T1.S1.\n3. LOGIC: In src/tools/mdsel-select.ts, define MDSEL_SELECT_SCHEMA constant with inputSchema: { type: 'object', properties: { selector: { type: 'string', description: 'Selector string' }, files: { type: 'array', items: { type: 'string' }, description: 'Array of file paths' } }, required: ['selector', 'files'] }.\n4. OUTPUT: src/tools/mdsel-select.ts with schema constant for P1.M3.T2.S2."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T2.S2",
                  "title": "Implement handleMdselSelect function",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Must return mdsel output verbatim with no post-processing (PRD Section 4.2).\n2. INPUT: MDSEL_SELECT_SCHEMA from P1.M3.T2.S1, execMdsel from P1.M2.T1.S2.\n3. LOGIC: In src/tools/mdsel-select.ts, implement async function handleMdselSelect(args: { selector: string; files: string[] }): Promise<ToolResult>. Call execMdsel(['select', args.selector, ...args.files]). Return { content: [{ type: 'text', text: result.stdout }], isError: !result.success }. No selector validation, no transformation.\n4. OUTPUT: src/tools/mdsel-select.ts with handleMdselSelect() for MCP server."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T2.S3",
                  "title": "Write tests for mdsel_select handler",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Test verbatim passthrough including error cases (PRD Section 8).\n2. INPUT: handleMdselSelect from P1.M3.T2.S2.\n3. LOGIC: Create tests/tools/mdsel-select.test.ts. Test cases: (1) Valid selector returns JSON content, (2) Invalid selector returns mdsel error JSON verbatim (not rewritten), (3) Selector not found returns mdsel response with unresolved array, (4) Output is raw mdsel JSON. Mock execMdsel.\n4. OUTPUT: tests/tools/mdsel-select.test.ts with passing tests."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P1.M4",
          "title": "MCP Server Integration",
          "status": "Planned",
          "description": "Wire up tool handlers into MCP server with proper tool definitions and behavioral descriptions.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M4.T1",
              "title": "Create MCP Server Entry Point",
              "status": "Planned",
              "description": "Implement main MCP server that exposes both tools with behavioral descriptions.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M4.T1.S1",
                  "title": "Define tool descriptions with behavioral guidance",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T1.S2",
                    "P1.M3.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Tool descriptions are behavioral infrastructure (PRD Section 7, plan/architecture/tool_definitions.md).\n2. INPUT: Tool handlers from P1.M3.T1.S2 and P1.M3.T2.S2.\n3. LOGIC: In src/index.ts, define TOOL_DEFINITIONS array with two entries. Each must include: name, title, description (behavioral - explicitly discourage Read for large MD files, include selector grammar, describe index→select workflow), inputSchema. Use exact descriptions from plan/architecture/tool_definitions.md.\n4. OUTPUT: TOOL_DEFINITIONS constant in src/index.ts for MCP server registration."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M4.T1.S2",
                  "title": "Implement MCP server with stdio transport",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M4.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: MCP SDK provides Server class with stdio transport (see plan/architecture/external_deps.md).\n2. INPUT: TOOL_DEFINITIONS from P1.M4.T1.S1, handlers from P1.M3.\n3. LOGIC: In src/index.ts, import { Server, StdioServerTransport } from '@modelcontextprotocol/sdk/server/index.js'. Create server with name='mdsel', version='1.0.0'. Register tools from TOOL_DEFINITIONS. Handle tool calls by routing to handleMdselIndex or handleMdselSelect. Connect with StdioServerTransport. Export server for testing.\n4. OUTPUT: src/index.ts as MCP server entry point, executable via 'node dist/index.mjs'."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M4.T1.S3",
                  "title": "Add bin entry to package.json",
                  "status": "Planned",
                  "story_points": 0.5,
                  "dependencies": [
                    "P1.M4.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: MCP servers are invoked as CLI commands.\n2. INPUT: Built server from P1.M4.T1.S2.\n3. LOGIC: Update package.json to add: bin: { 'mdsel-claude': './dist/index.mjs' }. Ensure dist/index.mjs has shebang (#!/usr/bin/env node) via tsup banner option or manual addition.\n4. OUTPUT: package.json with bin entry, server executable as 'mdsel-claude' or 'npx mdsel-claude'."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M4.T1.S4",
                  "title": "Write integration tests for MCP server",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [
                    "P1.M4.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Integration tests verify end-to-end tool invocation flow.\n2. INPUT: MCP server from P1.M4.T1.S2.\n3. LOGIC: Create tests/integration/server.test.ts. Test cases: (1) Server exposes exactly 2 tools (mdsel_index, mdsel_select), (2) Tool definitions include behavioral descriptions mentioning Read discouragement, (3) mdsel_index tool call returns valid response, (4) mdsel_select tool call returns valid response, (5) Errors from mdsel passed through unchanged. Use MCP SDK test utilities or spawn server subprocess.\n4. OUTPUT: tests/integration/server.test.ts verifying MVP functionality."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "Phase",
      "id": "P2",
      "title": "Behavioral Enforcement: Reminder Hook System",
      "status": "Planned",
      "description": "Implement the PreToolUse hook that intercepts Read tool invocations on Markdown files and injects reminder messages when word count exceeds threshold.",
      "milestones": [
        {
          "type": "Milestone",
          "id": "P2.M1",
          "title": "Word Count Gating Logic",
          "status": "Planned",
          "description": "Implement word counting utility and threshold comparison logic.",
          "tasks": [
            {
              "type": "Task",
              "id": "P2.M1.T1",
              "title": "Implement Word Count Utility",
              "status": "Planned",
              "description": "Create mechanical word counter based on whitespace-delimited tokens.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M1.T1.S1",
                  "title": "Implement countWords function",
                  "status": "Planned",
                  "story_points": 0.5,
                  "dependencies": [
                    "P1.M1.T1.S5"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Word count is mechanical, whitespace-delimited, not semantic (PRD Section 5.2).\n2. INPUT: Directory structure from P1.M1.T1.S5.\n3. LOGIC: Create src/lib/word-count.ts. Implement function countWords(content: string): number. Split by /\\s+/, filter empty strings, return length. This is intentionally simple - no semantic analysis.\n4. OUTPUT: src/lib/word-count.ts exporting countWords() for hook."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M1.T1.S2",
                  "title": "Implement getWordThreshold function",
                  "status": "Planned",
                  "story_points": 0.5,
                  "dependencies": [
                    "P2.M1.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: MDSEL_MIN_WORDS env var with default 200 (PRD Section 5.1).\n2. INPUT: countWords from P2.M1.T1.S1.\n3. LOGIC: In src/lib/word-count.ts, add function getWordThreshold(): number. Read process.env.MDSEL_MIN_WORDS, parse as integer, default to 200 if missing/invalid. Export both countWords and getWordThreshold.\n4. OUTPUT: src/lib/word-count.ts with threshold logic for hook."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M1.T1.S3",
                  "title": "Write tests for word count utilities",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M1.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Tests must verify mechanical counting and env var handling.\n2. INPUT: countWords and getWordThreshold from P2.M1.T1.S2.\n3. LOGIC: Create tests/lib/word-count.test.ts. Test countWords: (1) Empty string returns 0, (2) Single word returns 1, (3) Multiple spaces handled, (4) Newlines/tabs count as separators. Test getWordThreshold: (1) Default is 200, (2) Env var overrides default, (3) Invalid env var falls back to 200.\n4. OUTPUT: tests/lib/word-count.test.ts with passing tests."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P2.M2",
          "title": "PreToolUse Hook Implementation",
          "status": "Planned",
          "description": "Implement the Read tool interceptor hook that checks Markdown files and injects reminders.",
          "tasks": [
            {
              "type": "Task",
              "id": "P2.M2.T1",
              "title": "Implement Read Hook Script",
              "status": "Planned",
              "description": "Create standalone hook script that intercepts Read tool calls and injects reminders for large Markdown files.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M2.T1.S1",
                  "title": "Define hook input/output types",
                  "status": "Planned",
                  "story_points": 0.5,
                  "dependencies": [
                    "P2.M1.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Hook JSON schema defined in plan/architecture/hook_system.md.\n2. INPUT: Word count utilities from P2.M1.T1.S2.\n3. LOGIC: In src/types.ts, add interfaces: HookInput { session_id: string; hook_event_name: string; tool_name: string; tool_input: { file_path: string } }. HookOutput { continue: boolean; systemMessage?: string }.\n4. OUTPUT: src/types.ts with HookInput, HookOutput interfaces for hook script."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M2.T1.S2",
                  "title": "Implement read-hook.ts script",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [
                    "P2.M2.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Hook flow and reminder message in plan/architecture/hook_system.md.\n2. INPUT: HookInput/HookOutput from P2.M2.T1.S1, countWords/getWordThreshold from P2.M1.T1.S2.\n3. LOGIC: Create src/hooks/read-hook.ts as standalone executable (#!/usr/bin/env node). Read JSON from stdin. Check if file_path ends with '.md'. If not, output {continue:true} and exit 0. If yes, read file, count words, compare to threshold. If word_count > threshold, output {continue:true, systemMessage:'This is a Markdown file over the configured size threshold.\\nUse mdsel_index and mdsel_select instead of Read.'}. CRITICAL: Message must be EXACT per PRD Section 6.3. Always exit 0 (never block).\n4. OUTPUT: src/hooks/read-hook.ts as executable hook script."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M2.T1.S3",
                  "title": "Add read-hook to tsup build config",
                  "status": "Planned",
                  "story_points": 0.5,
                  "dependencies": [
                    "P2.M2.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Hook must be built as separate executable.\n2. INPUT: read-hook.ts from P2.M2.T1.S2, tsup.config.ts from P1.M1.T1.S3.\n3. LOGIC: Update tsup.config.ts to add 'src/hooks/read-hook.ts' to entry array. Ensure output is dist/read-hook.mjs with executable permissions (banner: '#!/usr/bin/env node').\n4. OUTPUT: tsup.config.ts building both index.mjs and read-hook.mjs."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M2.T1.S4",
                  "title": "Write tests for read-hook script",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [
                    "P2.M2.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Tests verify all trigger conditions from plan/architecture/hook_system.md.\n2. INPUT: read-hook.ts from P2.M2.T1.S2.\n3. LOGIC: Create tests/hooks/read-hook.test.ts. Test cases: (1) Non-.md file returns {continue:true} with no systemMessage, (2) Small .md file (<=200 words) returns {continue:true} with no systemMessage, (3) Large .md file (>200 words) returns {continue:true, systemMessage: EXACT_REMINDER}, (4) Missing file returns {continue:true} (let Read handle error), (5) MDSEL_MIN_WORDS env var respected. Create test fixtures with various word counts.\n4. OUTPUT: tests/hooks/read-hook.test.ts with passing tests."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P2.M3",
          "title": "Hook Configuration Documentation",
          "status": "Planned",
          "description": "Create configuration examples and documentation for installing the hook in Claude Code settings.",
          "tasks": [
            {
              "type": "Task",
              "id": "P2.M3.T1",
              "title": "Create Hook Configuration Guide",
              "status": "Planned",
              "description": "Document how to configure the PreToolUse hook in Claude Code settings.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M3.T1.S1",
                  "title": "Create example .claude/settings.json",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M2.T1.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Hook configuration format in plan/architecture/hook_system.md.\n2. INPUT: Built read-hook.mjs from P2.M2.T1.S3.\n3. LOGIC: Create .claude/settings.example.json with hooks configuration: { hooks: { PreToolUse: [{ matcher: 'Read', hooks: [{ type: 'command', command: 'node /path/to/mdsel-claude/dist/read-hook.mjs' }] }] } }. Include comments explaining configuration. Also add MCP server configuration for mdsel tools.\n4. OUTPUT: .claude/settings.example.json for user reference."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M3.T1.S2",
                  "title": "Create installation instructions in README",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M3.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: README should document both MCP server and hook setup.\n2. INPUT: Example settings from P2.M3.T1.S1.\n3. LOGIC: Create README.md sections: (1) Overview - behavioral conditioning for mdsel, (2) Prerequisites - mdsel CLI installed, Node.js >=18, (3) Installation - npm install, npm run build, (4) Claude Code Configuration - MCP server setup and hook setup with exact JSON, (5) Environment Variables - MDSEL_MIN_WORDS, (6) Usage - workflow of index→select. Keep minimal per PRD philosophy.\n4. OUTPUT: README.md with installation and configuration guide."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "Phase",
      "id": "P3",
      "title": "Polish & Validation",
      "status": "Planned",
      "description": "Final integration testing, linting, and validation that the system meets PRD success criteria.",
      "milestones": [
        {
          "type": "Milestone",
          "id": "P3.M1",
          "title": "End-to-End Validation",
          "status": "Planned",
          "description": "Validate complete system behavior against PRD success criteria.",
          "tasks": [
            {
              "type": "Task",
              "id": "P3.M1.T1",
              "title": "Create E2E Test Suite",
              "status": "Planned",
              "description": "Comprehensive tests validating PRD success criteria.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P3.M1.T1.S1",
                  "title": "Test mdsel output passthrough fidelity",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M4.T1.S4",
                    "P2.M2.T1.S4"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: PRD Section 11 - 'No divergence from mdsel output is observed'.\n2. INPUT: Complete MCP server and hook from previous phases.\n3. LOGIC: Create tests/e2e/output-fidelity.test.ts. For each tool (index, select): call mdsel CLI directly, call tool handler, compare outputs byte-for-byte. Test with valid inputs, invalid selectors, missing files. Output must be IDENTICAL to direct mdsel invocation.\n4. OUTPUT: tests/e2e/output-fidelity.test.ts proving no output divergence."
                },
                {
                  "type": "Subtask",
                  "id": "P3.M1.T1.S2",
                  "title": "Test reminder hook consistency",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M2.T1.S4"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: PRD Section 6.2 - reminder fires every time, no suppression.\n2. INPUT: read-hook from P2.M2.T1.S2.\n3. LOGIC: Create tests/e2e/reminder-consistency.test.ts. Test cases: (1) Call hook 10 times with same large file - all return identical systemMessage, (2) No suppression after first call, (3) Message is EXACTLY as specified in PRD 6.3. Verify repetition behavior.\n4. OUTPUT: tests/e2e/reminder-consistency.test.ts validating reminder frequency."
                },
                {
                  "type": "Subtask",
                  "id": "P3.M1.T1.S3",
                  "title": "Verify exactly 2 tools exposed",
                  "status": "Planned",
                  "story_points": 0.5,
                  "dependencies": [
                    "P1.M4.T1.S4"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: PRD Section 4 - 'Exactly two tools. No more. No fewer.'\n2. INPUT: MCP server from P1.M4.T1.S2.\n3. LOGIC: Create tests/e2e/tool-surface.test.ts. Query MCP server for tool list. Assert exactly 2 tools: mdsel_index and mdsel_select. Fail if any other tools present.\n4. OUTPUT: tests/e2e/tool-surface.test.ts enforcing tool count constraint."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P3.M1.T2",
              "title": "Code Quality and CI Setup",
              "status": "Planned",
              "description": "Configure linting, formatting, and continuous integration.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P3.M1.T2.S1",
                  "title": "Configure ESLint and Prettier",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Follow mdsel project patterns for linting.\n2. INPUT: package.json from P1.M1.T1.S1.\n3. LOGIC: Create eslint.config.js with TypeScript ESLint, prettier integration. Create .prettierrc.json with consistent formatting. Add lint and format scripts to package.json. Run linter on all source files.\n4. OUTPUT: eslint.config.js, .prettierrc.json, passing lint check."
                },
                {
                  "type": "Subtask",
                  "id": "P3.M1.T2.S2",
                  "title": "Add prepublishOnly and quality scripts",
                  "status": "Planned",
                  "story_points": 0.5,
                  "dependencies": [
                    "P3.M1.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Ensure quality gates before publish.\n2. INPUT: ESLint/Prettier config from P3.M1.T2.S1.\n3. LOGIC: Update package.json scripts: prepublishOnly='npm run lint && npm run test:run && npm run build', type-check='tsc --noEmit'. Ensure all quality gates pass.\n4. OUTPUT: package.json with complete quality scripts."
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}